<?php
	
	/***
	 * phpFileHandler - All in one PHP file handling class
	 */
	class phpFileHandler {
		
		/**
		 * The phpFileHandler Version number
		 * @var string
		 */
		public $Version = '1.0';
		
		/**
		 * Is ... extension loaded?
		 * @var boolean $is_mbstring_ext Is the mbstring extension loaded?
		 * @var boolean $is_gd2_ext Is the gd2 extension loaded?
		 */
		public $is_mbstring_ext;
		public $is_gd2_ext;
		
		/**
		 * Got phpFileHandler->add_uploaded_files() called?
		 * @var boolean
		 */
		public $is_add_uploaded = false;
		
		/**
		 * Shall @phpFileHandler->save() generate unique filenames?
		 * @var boolean
		 */
		public $is_uniq_filenames = true;
		
		/**
		 * The string length generated by @phpFileHandler::uniqString() for the phpFileHandler->save() filenames
		 * Only when @phpFileHandler->$is_uniq_filenames = true
		 * @var integer
		 */
		public $uniq_string_length = 12;
		
		/**
		 * The maximum allowed filesize in bytes
		 * '0' means no limit, NOTE that this does NOT represent the 'post_max_size' or 'upload_max_filesize' set in the php.ini,
		 * $_POST and $_FILES superglobals are empty if the the maximum '-> POST size is exceeded !
		 * @var integer
		 */
		public $MaxFileSize = 0;
		
		/**
		 * The allowed file types
		 * @var array
		 */
		public $AllowedFileTypes;
		
		/**
		 * Set to true to only let a file pass when it paases the $AllowedFileTypes AND file signature check
		 * * See -> guess_fileextension() for which file signatures can be detected
		 * @var boolean
		 */
		public $is_strict_filetypes = false;
		
		/**
		 * An error String containing information about non fatal errors like invalid file uploads
		 * Secure for user output
		 * @var string
		 */
		//public $Error = '';
		
		/**
		 * File packs
		 * @var array $Files All added files
		 * @var array $Files_valid The valid sanitized files ready for further phpFileHandler usage
		 * @var array $Files_invalid The invalid files which could not passed the sanitize checks
		 */
		public $Files = array();
		public $Files_valid = array();
		public $Files_invalid = array();
		
		/**
		 * File counters
		 * @var integer $Files_count added files count
		 * @var integer $Files_valid_count valid file count
		 * @var integer $Files_invalid_count invalid file count
		 */
		public $Files_count = 0;
		public $Files_valid_count = 0;
		public $Files_invalid_count = 0;
		
		/**
		 * Allowed file types presets
		 * @var array FTY_IMAGES_COMMON typical for default image only uploads
		 * @var array FTY_IMAGES_GD all types processable with the PHP GD extension
		 * @var array FTY_VIDEO_COMMON typical for default video only uploads
		 * @var array FTY_MEDIA_COMMON common image & videos
		 */
		const FTY_IMAGES_COMMON = ['jpg','gif','png'];
		const FTY_IMAGES_GD = ['jpg','gif','png','gd','gd2','bmp','wbmp','webp','xbm','xpm'];
		const FTY_VIDEO_COMMON = ['mp4','webm'];
		const FTY_MEDIA_COMMON = ['jpg','gif','png','mp4','webm'];
		
		/**
		 * Error severity: 
		 * @var integer ERR_FILE_UPLOAD_SIZE file exceeding the maximum filesize limit
		 * @var integer ERR_FILE_TYPE filetype is not allowed
		 * @var integer ERR_FILE_URL_READ could not reach or read the file from the URL location
		 * @var integer ERR_FILE_NOTEXIST file does not exist
		 */
		const ERR_FILE_UPLOAD_SIZE = 0;
		const ERR_FILE_TYPE = 1;
		const ERR_FILE_URL_READ = 2;
		const ERR_FILE_NOTEXIST = 3;
		
		/**
		 * Constructor
		 */
		public function __construct() {
			// check if the mbstring extension is loaded
			$this->is_mbstring_ext = extension_loaded( 'mbstring' );
			$this->is_gd2_ext = extension_loaded( 'gd2' );
		}
		
		/**
		 * Set the maximum filesize
		 * @param integer $size The maximum filesize in megabytes, or "0" for no limit
		 * @param boolean $isMB Whether or not $size is in megabyte format
		 */
		public function setMaxFileSize( $size, $isMB = true ) {
			$size = ( $size < 0 ) ? 0 : $size;
			// convert to byte if $isMB = true
			$this->MaxFileSize = ( $isMB ) ? $size * 100000 : $size;
		}
		
		/**
		 * Sets the allowed file types, which counts as valid for the next file adds
		 * @param array $types pass False for no restriction
		 */
		public function setAllowedFileTypes( $types ) {
			if ( $types === false ) {
				// allow all filetypes
				$this->AllowedFileTypes = null;
			} else {
				$types = (array)$types;
				for( $i = 0, $count = count( $types ); $i < $count; $i++ ) {
					$types[$i] = (string)$types;
				}
				$this->AllowedFileTypes = $types;
			}
		}
		
		/**
		 * Whether filechecking pass shall be strict or not
		 * @param boolean $bool
		 */
		public function setStrictFilecheck( $bool ) {
			$this->is_strict_filetypes = (boolean)$bool;
		}
		
		/**
		 * Whether the filesnames will become a unique name after phpFileHandler->save() got called or not
		 * @param boolean $bool
		 */
		public function setUniqFilenames( $bool ) {
			$this->is_uniq_filenames = (boolean)$bool;
		}
		
		/**
		 * Set the default filename length generated by phpFileHandler::uniqString() when called from phpFileHandler->save()
		 * @param integer $length
		 */
		public function setUniqFilenameLength( $length ) {
			$this->uniq_string_length = (int)$length;
		}
		
		/**
		 * Generate a unique random string (for multiple calls directly successively the $length should be atleast 10 otherwise it will generate the same strings )
		 * @param integer $length The length of the output string, must be greater than 0
		 * @return string A unique alphanumeric string 
		 */
		public static function uniqString( $length = 12 ) {
			// if $length is less than 1 the output string would be ~9 characters long
			$lenght = ( $length < 1 ) ? 1 : $length;
			
			$uString = base_convert( microtime( true ), 10, 36 );
			$padLength = $length - strlen( $uString );
			
			// if $padLength is greater than 0, extend to string to the given $length using random byte generator combined with hex conversion
			// else substring it to the given $length
			if ( $padLength > 0 ) {
				if ( version_compare( PHP_VERSION, '7.0.0' ) >= 0 ) {
					$rBytes = random_bytes( ceil( $padLength / 2 ) );
				} else {
					$rBytes = openssl_random_pseudo_bytes( ceil( $padLength / 2 ) );
				}
				$uString = str_pad( $uString, $length, bin2hex( $rBytes ) );
			} else {
				$uString = substr( $uString, -$length );
			}
			
			return $uString;
		}
		
		/**
		 * Adds all files from the PHP superglobal $_FILES
		 */
		public function add_uploaded_files() {
			if ( $this->is_add_uploaded ) {
				return;
			}
			$this->is_add_uploaded = true;
			foreach( $_FILES as $key => $data ) {
				$data['tmp_name'] = (array)$data['tmp_name'];
				$data['name'] = (array)$data['name'];
				$data['error'] = (array)$data['error'];
				for( $i = 0, $count = count( $data['tmp_name'] ); $i < $count; $i++ ) {
					$file = array(	'path'	=> $data['tmp_name'][$i],
										'origname' => $data['name'][$i],
										'name' => self::strip_to_valid_filename( $data['name'][$i] ),
										'mime' => $data['type'][$i],
										'isnew' => true	);
					
					// php.ini -> 'upload_max_filesize' exceeded error
					if ( $data['error'][$i] === UPLOAD_ERR_INI_SIZE ) {
						$this->add_invalid_file( $file, self::ERR_FILE_UPLOAD_SIZE ); 
						continue;
					}
				
					$this->process_file_add( $file );
				}
			}
		}
		
		/**
		 * Add a file from a web url
		 * @param string $url The file's web url
		 */
		public function add_file_from_url( $url ) {
			$url = ( substr( $url, 0, 4 ) !== 'http' ) ? 'http://' . str_replace( '//', '', $url ) : $url;
			$file = array(	'path'	=> $url,
								'origname' => $url,
								'name' => self::strip_to_valid_filename( substr( strrchr( $url, '/' ), 1 ) ),
								'isnew' => true	);
			$this->process_file_add( $file, true );
		}
		
		/**
		 * Adds files which are already existing on the Server for further processing
		 * @param string | array $filenames The file paths to add
		 */
		public function add_existing_files( $filenames ) {
			$filenames = (array)$filenames;
			for( $i = 0, $count = count( $filenames ); $i < $count; $i++ ) {
				if ( file_exists( $filenames[$i] ) ) {
					$pathinfo = pathinfo( $filenames[$i] );
					$this->process_file_add( array(	'path'	=> $filenames[$i],
																	'origname' => $pathinfo['basename'],
																	'name' => $pathinfo['basename'],
																	'savename' => $pathinfo['basename'] . '.' . $pathinfo['extension'],
																	'isnew' => false,
																	'ext' => $pathinfo['extension']	)	);
				} else {
					$this->add_invalid_file( array( 'path' => $filenames[$i] ), self::ERR_FILE_NOTEXIST ); 
				}
			}
		}
		
		/**
		 * Runs a file trough the main file checking process which is the only way to get valid files into @phpFileHandler->Files_valid
		 * @param array $file A phpFileHandler $file array
		 * @param boolean $isUrl True if $file['path'] is an web url
		 */
		protected function process_file_add( $file, $isUrl = false ) {
			// get the raw file content
			$filecontent = self::getFileContents( $file['path'], $isUrl );
			
			if ( $filecontent === false || empty( $filecontent ) ) {
				return $this->add_invalid_file( $file, ( $isUrl ) ? self::ERR_FILE_URL_READ : self::ERR_FILE_NOTEXIST ); 
			}
			
			if ( !isset( $file['ext'] ) || empty( $file['ext'] ) ) {
				// guess the file extension
				$file['ext'] = guess_fileextension( null, $filecontent );
				if ( !$file['ext'] ) {
					// if file extension could not be guessed and @is_strict_filetypes is set to true.. dont let the file pass
					if ( $this->is_strict_filetypes && $file['isnew'] ) {
						return $this->add_invalid_file( $file, self::ERR_FILE_TYPE ); 
					}
					if ( isset( $file['mime'] ) && !empty( $file['mime'] ) ) {
						$ext_guess = substr( strrchr( $file['mime'], '/' ), 1 );
					} else if ( strpos( $file['name'], '.' ) !== false ) {
						$ext_guess = substr( strrchr( $file['name'], '.' ), 1 );
					}
					$file['ext'] = str_replace( 'jpeg', 'jpg', $ext_guess ?? 'file' );
				}
			}
			
			// get the file size using mb_strlen or strlen (fallback when php_mbstring module is not loaded)
			// Note that this is only accurate when using mb_strlen because of mbstring.func_overload (which has been DEPRECATED as of PHP 7.2.0)
			$filesize = ( $this->is_mbstring_ext ) ? mb_strlen( $filecontent, '8bit' ) : strlen( $filecontent );
			if ( $this->MaxFileSize !== 0 && $filesize > $this->MaxFileSize ) {
				return $this->add_invalid_file( $file, self::ERR_FILE_UPLOAD_SIZE ); 
			}
			
			if ( $this->AllowedFileTypes ) {
				
				// check if the extension is allowed
				if ( !in_array( $file['ext'], $this->AllowedFileTypes ) ) {
					return $this->add_invalid_file( $file['ext'], self::ERR_FILE_TYPE ); 
				}
				
				// if its a known media file make a hard filetype check
				// if ( !self::check_mediafile( $filecontent, $file['ext'] ) ) {
					// return $this->add_invalid_file( $file, self::ERR_FILE_TYPE ); 
				// }
			}
			
			// filter the filename and remove the extension
			$dot_pos = strrpos( $file['name'], '.' );
			$file['name'] = ( $dot_pos !== false ) ? substr( $file['name'], 0, $dot_pos ) : $file['name'];
			
			if ( $isUrl ) {
				// generate a random temporary name for the file and save it to the system's default temp directory
				$file['path'] = tempnam( sys_get_temp_dir(), self::uniqString( 24 ) );
				file_put_contents( $file['path'], $filecontent );
			}
			
			if ( $this->is_gd2_ext ) {
				// check the orientation for the common image types
				if ( in_array( $file['ext'], self::FTY_IMAGES_GD ) ) {
					$this->fix_image_orientation( $file['path'], $filecontent );
				}
			}
			
			$file['size'] = $filesize;
			$this->add_valid_file( $file );
		}
		
		/**
		 * Saves all files in phpFileHandler->Files_valid to the given $savepath
		 * @param string $to The file save path
		 * @param boolean $allow_dir_create True to allow phpFileHandler to create the save path if not existing (recursive)
		 * @param integer $file_index Index of an phpFileHandler->Files_valid file
		 * @param string $name A custom filename when saving a single file
		 * @return boolean | null True on success, false on failure OR null when passing an undefined *array index*
		 */
		public function save( $to, $allow_dir_create = false, $file_index = null, $name = null ) {
			$to = self::prepare_dir_string( $to );
			self::try_create_folder( $to, $allow_dir_create );
			if ( $file_index === null ) {
				for( $i = 0; $i < $this->Files_valid; $i++ ) {
					// generate a new filename or take the original
					$name = ( $this->is_uniq_filenames ) ? self::uniqString( $this->uniq_string_length ) : $this->Files_valid[$i]['name'];
					$savename = $name . '.' . $this->Files_valid[$i]['ext'];
					$new_path = $to . $savename;
					self::move_file( $this->Files_valid[$i]['path'], $new_path, $allow_dir_create );
					$this->Files_valid[$i]['name'] = $name;
					$this->Files_valid[$i]['savename'] = $savename;
					$this->Files_valid[$i]['path'] = $new_path;
					$this->Files_valid[$i]['issaved'] = true;
				}
			} else {
				if ( isset( $this->Files_valid[ $file_index ] ) ) {
					if ( !$this->Files_valid[ $file_index ]['issaved'] ) {
						return false;
					}
					// is a custom filename set?
					if ( !$name ) {
						// generate a new filename or take the original
						$name = ( $this->is_uniq_filenames ) ? self::uniqString( $this->uniq_string_length ) : $this->Files_valid[ $file_index ]['name'];
					}
					$savename = $name . '.' . $this->Files_valid[ $file_index ]['ext'];
					$new_path = $to . $savename;
					self::move_file( $file['path'], $new_path, $allow_dir_create );
					$this->Files_valid[ $file_index ]['name'] = $name;
					$this->Files_valid[ $file_index ]['savename'] = $savename;
					$this->Files_valid[ $file_index ]['path'] = $new_path;
					$this->Files_valid[ $file_index ]['issaved'] = true;
				} else {
					return null;
				}
			}
			return true;
		}
		
		/**
		 * Securely moves or copys a file to a new location
		 * @param string $filename The full path to file
		 * @param string $to Move to path
		 * @param boolean $allow_dir_create True to allow phpFileHandler to create the save path if not existing (recursive)
		 * @param boolean $allow_override True to allow file override
		 * @param boolean $copy True to copy the file to the given location
		 * @return boolean True on success, False on failure
		 */
		public static function move_file( $filename, $to, $allow_dir_create = false, $allow_override = false, $copy = false ) {
			if ( !$allow_override && file_exists( $filename ) ) {
				return false;
			}
			self::try_create_folder( $to, $allow_dir_create );
			if ( $copy ) {
				return copy( $filename, $to );
			} else {
				if ( is_uploaded_file( $filename ) ) {
					// for in this session uploaded files only
					return move_uploaded_file( $filename, $to );
				} else {
					// every other files
					return rename( $filename, $to );
				}
			}
		}
		
		/**
		 * Securely deletes a folder
		 * @param string $dir Folder path
		 * @return boolean True on success, False on failure
		 */
		public static function delete_folder( $dir ) {
			if ( !is_dir( $dir ) ) {
				return false;
			}
			self::emtpy_folder( $dir );
			return rmdir( $dir );
		}
		
		/**
		 * Securely empties a folder
		 * @param string $dir Folder path
		 * @param boolean $keepSubFolders Whether or not to keep the sub folders
		 * @param array | string An array containing file extensions to avoid deleting (for a single extension a string can be passed too)
		 * @return boolean True on success, False on failure
		 */
		public static function emtpy_folder( $dir, $keepSubFolders = false, $fileExceptions = null ) {
			if ( !is_dir( $dir ) ) {
				return false;
			}
			$fileExceptions = ( $fileExceptions ) ? (array)$fileExceptions : $fileExceptions;
			$it = new RecursiveDirectoryIterator( $dir );
			$it = new RecursiveIteratorIterator( $it, RecursiveIteratorIterator::CHILD_FIRST );
			foreach( $it as $file ) {
				if ( $file->getBasename() === "." || $file->getBasename() === ".." ) {
					continue;
				}
				if ( $file->isDir() ) {
					// keep sub folder?
					if ( !$keepSubFolders ) {
						rmdir( $file->getPathname() );	// delete folder
					}
				} else {
					// is an exception file?
					if ( $fileExceptions && in_array( $file->getExtension(), $fileExceptions ) ) {
						continue;
					}
					unlink( $file->getPathname() );	// delete file
				}
			}
			return true;
		}
		
		/**
		 * Trys to create a folder (recursive)
		 * @param string $dir The folder path
		 * @param boolean $allow_dir_create
		 * @throws Exception IF the folder does not exists AND:
		 * * - $allow_dir_create is false
		 * * - PHP has no permission to create folders at the given location
		 */
		protected static function try_create_folder( $dir, $allow_dir_create ) {
			if ( !is_dir( $dir ) ) {
				if ( $allow_dir_create ) {
					if ( !mkdir( $dir, 0777, true ) ) {
						throw new Exception( 'Unable to create folder, check the parent folder\'s permissions it must be writable for the system user which executes PHP.' );
					}
				} else {
					throw new Exception( '"' . htmlspecialchars( $dir ) . '" path does not exist, set @param $allow_dir_create to TRUE to allow path creation.' );
				}
			}
		}
		
		/**
		 * Gets the raw file byte data as string
		 * @param string $filename Path to the file
		 * @return string | boolean The raw byte stream from the given file as string OR false if the file does not exist or the web url could not be reached
		 */
		protected static function getFileContents( $filename, $isUrl = false ) {
			$isUrl = ( !$isUrl && filter_var( $url, FILTER_VALIDATE_URL ) ) ? true : $isUrl;
			if ( $isUrl ) {
				// $filename is a web url
				try {
					$filecontent = file_get_contents(
						$filename, false,
						stream_context_create(
							array(
								'http' => array(
									'method' => 'GET',
									'timeout' => 10	// timout after a 10 seconds connection attempt
								)
							)
						), 0, $this->MaxFileSize
					);
				} catch( Exception $exc ) {
					return false;
				}
			} else {
				if ( !file_exists( $filename ) ) {
					return false;
				}
				$filecontent = file_get_contents( $filename );
			}
			return $filecontent;
		}
		
		/**
		 * Guesses the file's type by checking its signature
		 * @param string $filecontent A raw file content as string
		 * @return string | boolean Return the guessed file extension or false if the file or web url is invalid (see @->getFileContents()) none of the following signature could be found:
		 * * jpg (jpeg), gif, png, bmp, mp4, webm, webp, gzip, 7zip, rar, exe, tif, tiff, pdf, wav, avi, xml, mp3, wmv, wma
		 */
		public static function guess_fileextension( $filename = null, $filecontent = null ) {
			if ( $filename ) {
				$filecontent = self::getFileContents( $filename );
				if ( !$filecontent ) {
					return false;
				}
			} else if ( !$filecontent ) {
				throw new Exception( 'This function needs atleast one argument!' );
			}
			$signature = self::getFileSignature( $filecontent );
			switch( $signature[0] ) {
				case 'FF': { return ( self::is_jpg( null, $signature ) ) ? 'jpg' : (( self::is_mp3( null, $signature ) ) ? 'mp3' : false ); } break;
				case '47': { return ( self::is_gif( null, $signature ) ) ? 'gif' : false; } break;
				case '89': { return ( self::is_png( null, $signature ) ) ? 'png' : false; } break;
				case '42': { return ( self::is_bmp( null, $signature ) ) ? 'bmp' : false; } break;
				case '52': { return ( self::is_webp( null, $signature ) ) ? 'webp' : (( self::is_rar( null, $signature ) ) ? 'rar' : false ); } break;
				case '1F': { return ( self::is_gzip( null, $signature ) ) ? 'gz' : false; } break;
				case '37': { return ( self::is_7zip( null, $signature ) ) ? '7z' : false; } break;
				case '4D': { return ( self::is_exe( null, $signature ) ) ? 'exe' : (( self::is_tiff( null, $signature ) ) ? 'tiff' : false ); } break;
				case '49': { return ( self::is_tif( null, $signature ) ) ? 'tif' : (( self::is_mp3( null, $signature ) ) ? 'mp3' : false ); } break;
				case '25': { return ( self::is_pdf( null, $signature ) ) ? 'pdf' : false; } break;
				case '30': { return ( self::is_wmv( null, $signature ) ) ? 'wmv' : false; } break;
				case '75': { return ( self::is_tar( null, $signature ) ) ? 'tar' : false; } break;
				case '3C': { return ( self::is_xml( null, $signature ) ) ? 'xml' : false; } break;
				default: {
					$signature = self::getFileSignature( $filecontent, 4 );
					switch( $signature[0] ) {
						case '66': { return ( self::is_mp4( null, $signature ) ) ? 'mp4' : false; } break;
						case '1A': { return ( self::is_webm( null, $signature ) ) ? 'webm' : false; } break;
						default: {
							$signature = self::getFileSignature( $filecontent, 8 );
							switch( $signature[0] ) {
								case '57': { return ( self::is_wav( null, $signature ) ) ? 'wav' : false; } break;
								case '41': { return ( self::is_avi( null, $signature ) ) ? 'avi' : false; } break;
							}
						}
					}
				}
			}
			return false;
		}
		
		/**
		 * Converts raw filecontent file data to an array of x ($count) elements containing the hexadecimal representation of the bytes
		 * @param string $filecontent Raw file data
		 * @param integer $index The starting index
		 * @param integer $count The amount of bytes to convert and push into the returning array
		 * @return array of hexadecimal string elements
		 */
		public static function getFileSignature( $filecontent, $index = 0, $count = 4 ) {
			$signature = array();
			for( $range = $index + $count; $index < $range; $index++ ) {
				$signature[] = ( isset( $filecontent[ $index ] ) ) ? strtoupper( bin2hex( $filecontent[ $index ] ) ) : '';
			}
			return $signature;
		}
		
		/**
		 * Converts raw filecontent file data to an array of x ($count) elements containing the hexadecimal representation of the bytes
		 * @param array $comparison A signature array as comparison reference
		 * @param array $signature A signature array to compare against $comparison
		 * @param string $filename A filepath to get the signature from and compare against $comparison
		 * @param integer $index If $filename is given, $index defines the starting index from which byte to begin fetching the file's signature
		 * @return boolean True if the signature array equals the comparison
		 */
		public static function compareFileSignature( $comparison, $signature = null, $filename = null, $index = 0 ) {
			$count = count( $comparison );
			if ( $filename ) {
				$filecontent = self::getFileContents( $filename );
				if ( !$filecontent ) {
					return false;
				}
				$signature = self::getFileSignature( $filecontent, $index, $count );
			}
			for( $i = 0; $i < $count; $i++ ) {
				if ( $comparison[$i] !== $signature[$i] ) {
					return false;
				}
			}
			return true;
		}
		
		/**
		 * Checks if the file signature given as hexadecimal array is correct
		 * * see the description of ->guess_fileextension() for a list of checked file types
		 * @param string $filename The path to the file
		 * @param array $signature An array containing hexadecimal representation of bytes from a file
		 */
		public static function is_jpg( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('FF','D8','FF'), $signature, $filename );
		}
		public static function is_gif( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('47','49','46'), $signature, $filename );
		}
		public static function is_png( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('89','50','4E'), $signature, $filename );
		}
		public static function is_bmp( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('42','4D'), $signature, $filename );
		}
		public static function is_webp( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('52','49','46','46'), $signature, $filename );
		}
		public static function is_mp4( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('66','74','79','70'), $signature, $filename, 4 );
		}
		// detects a Matroska media container aka 'mkv', 'mka', 'mks', 'mk3d', 'webm'
		public static function is_webm( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('1A','45','DF','A3'), $signature, $filename, 4 );
		}
		public static function is_gzip( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('1F','8B'), $signature, $filename );
		}
		public static function is_7zip( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('37','7A','BC','AF'), $signature, $filename );
		}
		public static function is_rar( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('52','61','72','21'), $signature, $filename );
		}
		public static function is_exe( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('4D','5A'), $signature, $filename );
		}
		// little endian format
		public static function is_tif( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('49','49','2A','00'), $signature, $filename );
		}
		// big endian format
		public static function is_tiff( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('4D','4D','00','2A'), $signature, $filename );
		}
		public static function is_pdf( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('25','50','44','46'), $signature, $filename );
		}
		public static function is_wav( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('57','41','56','45'), $signature, $filename, 8 );
		}
		public static function is_avi( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('41','56','49','20'), $signature, $filename, 8 );
		}
		public static function is_tar( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('75','73','74','61'), $signature, $filename );
		}
		public static function is_xml( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('3C','3F','78','6D'), $signature, $filename );
		}
		// 49: mp3 with an ID3v2 container, FF: MPEG-1 Layer 3 without and ID3 tag or with an ID3v1 tag at the end of the file
		public static function is_mp3( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('49','44','33'), $signature, $filename ) || self::compareFileSignature( array('FF','FB'), $signature, $filename );
		}
		public static function is_wmv( $filename = null, $signature = null ) {
			return self::compareFileSignature( array('30','26','B2','75'), $signature, $filename );
		}
		// wma is identical to wmv in its basic internal structure, only difference is the extension and mime type..
		public static function is_wma( $filename = null, $signature = null ) {
			return self::is_wma( $filename, $signature );
		}
		
		/**
		 * Strips all characters except from the folowing: 'a-z'  'A-Z'  '0-9'  '_'  '-'  '.'
		 * @param string $string
		 * @return string The stripped string
		 */
		private static function strip_to_valid_filename( $string ) {
			return preg_replace( '/[^\w-.]/', '', $string );
		}
		
		/**
		 * Returns a proper directory string with a leading '/'
		 * @param string $dir
		 * @return string The proper directory string
		 * * '\' -> '/'
		 * * '/Dir\Path\Here' -> '/Dir/Path/Here/'
		 */
		private static function prepare_dir_string( $dir ) {
			return rtrim( str_replace( '\\', '/', $dir ), '/' ) . '/';
		}

		/**
		 * Adds an invalid file with its error to $Files_invalid
		 * Secure for client output as error messge
		 * @param array $file
		 * @param integer $errorCode An error severity constant
		 */
		protected function add_invalid_file( $file, $errorCode ) {
			switch( $errorCode ) {
				case self::ERR_FILE_UPLOAD_SIZE: { $errorMsg = 'Exceeding the maximum upload file size. '; } break;
				case self::ERR_FILE_TYPE: { $errorMsg = 'Filetype not allowed.'; } break;
				case self::ERR_FILE_URL_READ: { $errorMsg = 'Could not fetch the file from the web address.'; } break;
				case self::ERR_FILE_NOTEXIST: { $errorMsg = 'This file does not exist (anymore?) or is empty.'; } break;
			}
			$file['errorCode'] = $errorCode;
			$file['error'] = $errorMsg;
			$file['isvalid'] = false;
			
			$this->Files_invalid[] = $file;
			$this->Files_invalid_count++;
			$this->add_file( $file );
			
			// delete the file if it is a new one
			if ( $file['isnew'] ) {
				unlink( $file['path'] );
			}
		}
		
		/**
		 * Adds an valid file to $Files_valid
		 * @param array $file
		 */
		protected function add_valid_file( $file ) {
			$file['errorCode'] = null;
			$file['error'] = '';
			$file['isvalid'] = true;
			$file['name'] = ( empty( $file['name'] ) ) ? self::uniqString() : $file['name'];
			$file['issaved'] = false;
			$file['savename'] = $file['savename'] ?? null;
			
			$this->Files_valid[] = $file;
			$this->Files_valid_count++;
			$this->add_file( $file );
		}
		
		/**
		 * Adds an added file regardless of whether valid or invalid to $Files
		 * @param array $file
		 */
		protected function add_file( $file ) {
			$this->Files[] = $file;
			$this->Files_count++;
		}
		
	/******
	 *			-------------------------------------------------------------
	 *			|															|
	 *			|		IMAGE HANDLING SECTION 		|
	 *			|															|
	 *			-------------------------------------------------------------
	 *
	 * phpImageHandler - All in one php image handling using the GD extension !
	 * make sure the gd2 extension is loaded
	 * NOTE: For very big images the script memory usage may need to be elevated
	 * On my machine (WIN7, XAMPP, PHP7) a 12MB image took ~32MB on peak
	 * PHP's default 'memory_limit' is set to '128M'...
	 * Nonetheless you will notice when getting the Fatal error: 'Out of memory' occurs
	 *
	 **/

		/*
		 * Create a thumbnail in the same folder as the reference image
		 * if $filename is null, it will create a thumb from every image file from @phpFileHandler->Files_valid
		 * @param string $size See @param $type for explanation
		 * @param string $type The thumb generation type
		 * * If the image is smaller than $size it will just create a copy with the prefixed name
		 * * - '': $size will define the maximum height or width depending on the largest side, image will scale down proportional
		 * * - 'iso': The image will be cropped centered to a Isosceles square each side with the lenght of $size
		 * @param string $prefix Adds a prefix after the filename ( 'image.jpg' -> 'image_thumb.jpg' )
		 * * Note when you set an empty prefix if a file with the same name exists in the given directory it will be overwritten !
		 * @param boolean $allowGrowth Whether or not to allow a bigger output image
		 * @param string $to Set a save path for the thumb
		 * @param string $filename Path to the image file
		 */
		public function thumb( $size, $type = '', $prefix = '_thumb', $allowGrowth = false, $to = null, $filename = null ) {
			if ( $to ) {
				if ( !is_dir( $to ) ) {
					throw new Exception( htmlspecialchars( $to ) . ' is not a directory or does not exist.' );
				}
				$to = self::prepare_dir_string( $to );
			}
			if ( !$filename ) {
				// generate a thumb for each of the phpFileHandler->Files_valid
				for( $i = 0; $i < $this->Files_valid; $i++ ) {
					if ( in_array( $this->Files_valid[$i]['ext'], self::FTY_IMAGES_GD ) ) {
						$savepath = ( !$to ) ? $this->Files_valid[$i]['path'] : $to . $this->Files_valid[$i]['savename'];
						$image = self::create_image( $this->Files_valid[$i]['path'], $this->Files_valid[$i]['ext'], $size, $type, $allowGrowth );
						self::save_image( $image, $savepath, $this->Files_valid[$i]['ext'], $prefix );
					}
				}
			} else {
				if ( !file_exists( $filename ) ) {
					throw new Exception( 'File does not exist (' . htmlspecialchars( $filename ) . ')' );
				}
				// generate a thumb for the given file if its an image file which can be handled by GD
				$ext = substr( strrchr( $filename, '.' ), 1 );
				if ( in_array( $ext, self::FTY_IMAGES_GD ) ) {
					$savepath = ( !$to ) ? $filename : $to . substr( $filename, strrpos( $filename, '/' )+1 );
					$image = self::create_image( $filename, $ext, $size, $type, $allowGrowth );
					self::save_image( $image, $savepath, $ext, $prefix );
				}
			}
		}
		
		/*
		 * Resizes the image proportional
		 * * see @thumb() description for the details
		 * @param string $filename Path to the image file
		 * @param string $size See @param $type for explanation
		 * @param string $to Set a save path for the thumb
		 * @param string $prefix If not set the file will be overwritten (if the output is in the same folder)
		 */
		public function resize( $filename, $size, $to = null, $prefix = '' ) {
			$this->thumb( $size, $to, $filename, '', $prefix, true );
		}
		
		/*
		 * Converts an image file to the given ouput type
		 * @param string $filename Path to the image file
		 * @param string $output_type The output file type (see @save_image() for which output types are supported)
		 * @param boolean $keepOriginal whether to keep or delete the original file 
		 */
		public function convert_image( $filename, $output_type, $keepOriginal = false ) {
			if ( !file_exists( $filename ) ) {
				throw new Exception( 'File does not exist (' . htmlspecialchars( $filename ) . ')' );
			}
			$image = self::create_image( $filename );
			self::save_image( $image, $filename, $output_type );
			if ( !$keepOriginal ) {
				unlink( $filename );
			}
		}
		
		/*
		 * Try to fix the image's orientation
		 * @param string $filename Path to the image file
		 * @param string $filecontent The raw image content
		 * @return boolean False if the file does not exists else true
		 */
		public function fix_image_orientation( $filename, $filecontent = null ) {
			if ( !file_exists( $filename ) ) {
				return false;
			}
			$data = exif_read_data( $filename );
			if ( !empty( $data['Orientation'] ) ) {
				switch( $data['Orientation'] ) {
					case 3: { $newAngle = 180; } break;
					case 6: { $newAngle = -90; } break;
					case 8: { $newAngle = 90; } break;
					default: $newAngle = false;
				}
				if ( $newAngle ) {
					$image = imagecreatefromstring( ( !$filecontent ) ? self::getFileContents( $filename ) : $filecontent );
					$image = imagerotate( $image, $newAngle, 0 );
					self::save_image( $image, $file['path'], $file['ext'] );
				}
			}
			return true;
		}
		
		/*
		 * Adds an watermark to the image
		 * @param string $target Path to the target image
		 * @param string $watermark Path to the watermark image
		 * @param float $opacity The watermark's opacity From 0.00 (fully transparent) to 1.00 (fully visible)
		 * @param string $position The watermark's position
		 * @param integer $offsetX Horizontal offset
		 * @param integer $offsetY Vertical offset
		 */
		public function put_watermark( $target, $watermark, $opacity = 0.5, $position = 'center', $offsetX = 0, $offsetY = 0 ) {
			if ( !file_exists( $target ) ) {
				throw new Exception( 'Target file does not exist (' . htmlspecialchars( $target ) . ')' );
			} else if ( !file_exists( $watermark )  ) {
				throw new Exception( 'Watermark file does not exist (' . htmlspecialchars( $watermark ) . ')' );
			}
			
			// keep the opacity value in range
			$opacity = (int) ((( $opacity < 0 ) ? 0 : (( $opacity > 1 ) ? 1 : $opacity )) * 100);
			
			$target_image = self::create_image( $target );
			$target_width = imagesx( $target_image );
			$target_height = imagesy( $target_image );
			
			$watermark_image = self::create_image( $watermark );
			$watermark_width = imagesx( $watermark_image );
			$watermark_height = imagesy( $watermark_image );
			
			switch( $position ) {
				case 'top': {
					$x = ($target_width / 2) - ($watermark_width / 2) + $offsetX;
					$y = $offsetY;
				} break;
				case 'left': {
					$x = $offsetX;
					$y = ($target_height / 2) - ($watermark_height / 2) + $offsetY;
				} break;
				case 'right': {
					$x = $target_width - $watermark_width + $offsetX;
					$y = ($target_height / 2) - ($watermark_height / 2) + $offsetY;
				} break;
				case 'bottom': {
					$x = ($target_width / 2) - ($watermark_width / 2) + $offsetX;
					$y = $target_height - $watermark_height + $offsetY;
				} break;
				case 'top left': {
					$x = $offsetX;
					$y = $offsetY;
				} break;
				case 'top right': {
					$x = $target_width - $watermark_width + $offsetX;
					$y = $offsetY;
				} break;
				case 'bottom left': {
					$x = $offsetX;
					$y = $target_height - $watermark_height + $offsetY;
				} break;
				case 'bottom right': {
					$x = $target_width - $watermark_width + $offsetX;
					$y = $target_height - $watermark_height + $offsetY;
				} break;
				default: {	// center
					$x = ($target_width / 2) - ($watermark_width / 2) + $offsetX;
					$y = ($target_height / 2) - ($watermark_height / 2) + $offsetY;
				} break;
			}
			
			if ( $opacity < 100 ) {
				// workaround for transparent images because PHP's imagecopymerge does not support alpha channel
				imagealphablending( $watermark_image, false );
				imagefilter( $watermark_image, IMG_FILTER_COLORIZE, 0, 0, 0, 127 * ((100 - $opacity) / 100) );
			}

			// put the watermark on the target image
			imagecopy( $target_image, $watermark_image, $x, $y, 0, 0, $watermark_width, $watermark_height );
			
			imagedestroy( $watermark_image );
			
			self::save_image( $target_image, $target );
		}
		
		/**
		 * Generates the settings for the thumb used in imagecopyresampled() function
		 * * NOTE: imagecreatefrombmp is only availible for PHP 7 >= 7.2.0
		 * * NOTE: imagecreatefromwebp is only availible for PHP 5 >= 5.5.0, PHP 7
		 * @param integer $width Orignial image width
		 * @param integer $height Orignial image height
		 * @param integer $size The destination size
		 * @param string $type An image resource possible type
		 * @param boolean $allowGrowth Whether or not to allow a bigger output image
		 * @return resource An image resource
		 */
		private function create_image( $filename, $ext = null, $size = null, $type = null, $allowGrowth = false ) {
			// create an image resource from the original image
			$ext = ( !$ext ) ? substr( strrchr( $filename, '.' ), 1 ) : $ext;
			switch( $ext ) {
				case 'jpeg':
				case 'jpg': { $image = imagecreatefromjpeg( $filename ); } break;
				case 'gif': { $image = imagecreatefromgif( $filename ); } break;
				case 'png': { $image = imagecreatefrompng( $filename ); } break;
				case 'gd': { $image = imagecreatefromgd( $filename ); } break;
				case 'gd2': { $image = imagecreatefromgd2( $filename ); } break;
				case 'bmp': { $image = imagecreatefrombmp( $filename ); } break;
				case 'wbmp': { $image = imagecreatefromwbmp( $filename ); } break;
				case 'webp': { $image = imagecreatefromwebp( $filename ); } break;
				case 'xbm': { $image = imagecreatefromxbm( $filename ); } break;
				default: throw new Exception( 'GD extension cannot create an image from this image type ("' . htmlspecialchars( $ext ) . '")' ); 
			}
			
			if ( $size && $type ) {
				$image_width = imagesx( $image );
				$image_height = imagesy( $image );
				
				// get the settings for the thumb image creation
				$settings = self::generate_thumbsettings( $image_width, $image_height, $size, $type, $allowGrowth );

				// settings return false if the destination $size is bigger than the original image
				if ( $settings ) {
					// create a new empty image
					$new_image = imagecreatetruecolor( $settings['dst_width'], $settings['dst_height'] );
					if ( $ext !== 'jpeg' && $ext !== 'jpg' ) {
						// create an alpha canal for the image and set the background to fully transparent
						imagecolortransparent( $new_image, imagecolorallocatealpha( $new_image, 0, 0, 0, 127 ) );
						imagealphablending( $new_image, false );
						imagesavealpha( $new_image, true );
					}
					
					imagecopyresampled(
						$new_image, $image,									//	dst_image,	src_image,
						0, 0,																//	dst_x,			dst_y,
						$settings['x'], $settings['y'],								//	src_x,			src_y,
						$settings['dst_width'], $settings['dst_height'],	//	dst_w,			dst_h,
						$image_width, $image_height							//	src_w,			src_h
					);
					
					imagedestroy( $image );
					
					return $new_image;
				}
			}
			
			return $image;
		}
		
		/**
		 * Saves an image resource to a file 
		 * NOTE that this function will overwrite an existing file with the same name
		 * @param resource $image An image resource
		 * @param string $filename The full image saving path
		 * @param string $ext The filetype extension
		 * @param string $prefix Adds a prefix after the filename ( 'image.jpg' -> 'image_thumb.jpg' )
		 */
		protected static function save_image( $image, $saveto, $output_type = null, $prefix = '' ) {
			$ext = substr( strrchr( $saveto, '.' ), 1 );
			$output_type = ( !$output_type ) ? $ext : $output_type;
			
			// insert the prefix and / or
			// force the output filename have the output_type extension
			if ( !empty( $prefix ) || $ext !== $output_type ) {
				$saveto = substr( $saveto, 0, strrpos( $saveto, '.' )  ) . $prefix . '.' . $output_type;
			}
			
			switch( $output_type ) {
				case 'jpeg':
				case 'jpg': { imagejpeg( $image, $saveto ); } break;
				case 'gif': { imagegif( $image, $saveto ); } break;
				case 'png': { imagepng( $image, $saveto ); } break;
				case 'gd': { imagegd( $image, $saveto ); } break;
				case 'gd2': { imagegd2( $image, $saveto ); } break;
				case 'bmp': { imagebmp( $image, $saveto ); } break;
				case 'wbmp': { imagewbmp( $image, $saveto ); } break;
				case 'webp': { imagewebp( $image, $saveto ); } break;
				case 'xbm': { imagexbm( $image, $saveto ); } break;
				default: throw new Exception( 'GD extension cannot create an image from this image type ("' . htmlspecialchars( $ext ) . '")' ); 
			}
			
			imagedestroy( $image );
		}
		
		/**
		 * Generates the settings for the thumb used in imagecopyresampled() function
		 * @param integer $width Orignial image width
		 * @param integer $height Orignial image height
		 * @param integer $size The destination size
		 * @param string $type An image resource possible type
		 * @param boolean $allowGrowth Whether or not to allow a bigger output image
		 * @return array | boolean
		 * * false: $allowGrowth = false AND the destination size is bigger than the original
		 * * array with the calculated destination 'width', 'height', 'x', 'y'
		 */
		private static function generate_thumbsettings( $width, $height, $size, $type = '', $allowGrowth = false ) {
			switch( $type ) {
				case 'iso': {
					if ( $width < $height ) {
						if ( !$allowGrowth && $size > $height ) {
							return false;
						}
						$y = ( $height / 2 ) - ( $width / 2 );
						$height = $width;
					} else {
						if ( !$allowGrowth && $size > $width ) {
							return false;
						}
						$x = ( $width / 2 ) - ( $height / 2 );
						$width = $height;
					}
					$dst_width = $dst_height = $size;
				} break;
				default: {
					if ( $width > $height ) {
						if ( !$allowGrowth && $size > $width ) {
							return false;
						}
						$dst_width = $size;
						$dst_height = round( $size / ($width / $height) );
					} else {
						if ( !$allowGrowth && $size > $height ) {
							return false;
						}
						$dst_height = $size;
						$dst_width = round( $size / ($height / $width) );
					}
				}
			}
			return array(	'dst_width' => $dst_width,
								'dst_height' => $dst_height,
								'x' => $x ?? 0,
								'y' => $y ?? 0	);
		}
		
	}
