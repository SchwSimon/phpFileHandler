<?php
	
	/***
	 * phpFileHandler - All in one PHP file handling class
	 */
	class phpFileHandler {
		
		/**
		 * The phpFileHandler Version number
		 * @var string
		 */
		public $Version = '0.1';
		
		/**
		 * Is ... extension loaded?
		 * @var boolean $is_mbstring_ext Is the mbstring extension loaded?
		 * @var boolean $is_gd2_ext Is the gd2 extension loaded?
		 */
		public $is_mbstring_ext;
		public $is_gd2_ext;
		
		/**
		 * Got phpFileHandler->add_uploaded_files() called?
		 * @var boolean
		 */
		public $is_add_uploaded = false;
		
		/**
		 * Shall @phpFileHandler->save() generate unique filenames?
		 * @var boolean
		 */
		public $is_uniq_filenames = true;
		
		/**
		 * The string length generated by @phpFileHandler::uniqString() for the phpFileHandler->save() filenames
		 * Only when @phpFileHandler->$is_uniq_filenames = true
		 * @var integer
		 */
		public $uniq_string_length = 12;
		
		/**
		 * The maximum allowed filesize in bytes
		 * '0' means no limit, NOTE that this does NOT represent the 'post_max_size' or 'upload_max_filesize' set in the php.ini,
		 * $_POST and $_FILES superglobals are empty if the the maximum '-> POST size is exceeded !
		 * @var integer
		 */
		public $MaxFileSize = 0;
		
		/**
		 * The allowed file types
		 * @var array
		 */
		public $AllowedFileTypes;
		
		/**
		 * An error String containing information about non fatal errors like invalid file uploads
		 * Secure for user output
		 * @var string
		 */
		//public $Error = '';
		
		/**
		 * File packs
		 * @var array $Files All added files
		 * @var array $Files_valid The valid sanitized files ready for further phpFileHandler usage
		 * @var array $Files_invalid The invalid files which could not passed the sanitize checks
		 */
		public $Files = array();
		public $Files_valid = array();
		public $Files_invalid = array();
		
		/**
		 * File counters
		 * @var integer $Files_count added files count
		 * @var integer $Files_valid_count valid file count
		 * @var integer $Files_invalid_count invalid file count
		 */
		public $Files_count = 0;
		public $Files_valid_count = 0;
		public $Files_invalid_count = 0;
		
		/**
		 * Allowed file types presets
		 * @var array FTY_IMAGES_COMMON typical for default image only uploads
		 * @var array FTY_IMAGES_GD all types processable with the PHP GD extension
		 * @var array FTY_VIDEO_COMMON typical for default video only uploads
		 * @var array FTY_MEDIA_COMMON common image & videos
		 */
		const FTY_IMAGES_COMMON = ['jpg','gif','png'];
		const FTY_IMAGES_GD = ['jpg','gif','png','gd','gd2','bmp','wbmp','webp','xbm','xpm'];
		const FTY_VIDEO_COMMON = ['mp4','webm'];
		const FTY_MEDIA_COMMON = ['jpg','gif','png','mp4','webm'];
		
		/**
		 * Error severity: 
		 * @var integer ERR_FILE_UPLOAD_SIZE file exceeding the maximum filesize limit
		 * @var integer ERR_FILE_TYPE filetype is not allowed
		 * @var integer ERR_FILE_URL_SERVER could not reach or read the file from the URL location
		 */
		const ERR_FILE_UPLOAD_SIZE = 0;
		const ERR_FILE_TYPE = 1;
		const ERR_FILE_URL_READ = 2;
		
		/**
		 * Constructor
		 */
		public function __construct() {
			// check if the mbstring extension is loaded
			$this->is_mbstring_ext = extension_loaded( 'mbstring' );
			$this->is_gd2_ext = extension_loaded( 'gd2' );
		}
		
		/**
		 * Return an array containing information about the phpFileHandler and its current confirguration
		 * @param boolean $dump For direct browser output set to TRUE
		 */
		public function info( $dump = false ) {
			$info = array(	'Version' => $this->Version,
								'MaxFileSize' => $this->MaxFileSize . ' bytes ("0" means unlimited)' );
			return ( $dump ) ? var_dump( $info ) : $info;
		}
		
		/**
		 * Set the maximum filesize
		 * @param integer $size The maximum filesize in megabytes, or "0" for no limit
		 * @param boolean $isMB Wheter or not $size is in megabyte format
		 * @throws Exception
		 */
		public function setMaxFileSize( $size, $isMB = true ) {
			if ( $size < 0 ) {
				throw new Exception( 'phpFileHandler->setMaxSize() @var $size must be greater or equal "0"' );
			}
			// convert to byte if $isMB = true
			$this->MaxFileSize = ( $isMB ) ? $size * 100000 : $size;
		}
		
		/**
		 * Sets the allowed file types, which counts as valid for the next file adds
		 * @param array $types pass False for no restriction
		 */
		public function setAllowedFileTypes( $types ) {
			if ( $types === false ) {
				// allow all filetypes
				$this->AllowedFileTypes = null;
			} else {
				$types = (array)$types;
				for( $i = 0, $count = count( $types ); $i < $count; $i++ ) {
					$types[$i] = (string)$types;
				}
				$this->AllowedFileTypes = $types;
			}
		}
		
		/**
		 * Sets the allowed file types, which counts as valid for the next file adds
		 * @param array $types pass False for no restriction
		 */
		public function setUniqFilenames( $bool, $length = null ) {
			$bool = (boolean)$bool;
			$this->is_uniq_filenames = $bool;
			if ( $bool ) {
				$this->uniq_string_length = ( !$length ) ? $this->uniq_string_length : (int)$length;
			}
		}
		
		/**
		 * Generate a unique random string (for multiple calls directly successively the $length should be atleast 10 otherwise it will generate the same strings )
		 * @param integer $length The length of the output string, must be greater than 0
		 * @throws Exception
		 */
		public static function uniqString( $length = 12 ) {
			if ( $length < 1 ) {
				// if $length is less than 1 the output string would be ~9 characters long
				throw new Exception( 'phpFileHandler::uniqString() @var $length must be greater than "0"' );
			}
			$uString = base_convert( microtime( true ), 10, 36 );
			$padLength = $length - strlen( $uString );
			
				// if $padLength is greater than 0, extend to string to the given $length using random byte generator combined with hex conversion
				// else substring it to the given $length
			if ( $padLength > 0 ) {
				if ( version_compare( PHP_VERSION, '7.0.0' ) >= 0 ) {
					$rBytes = random_bytes( ceil( $padLength / 2 ) );
				} else {
					$rBytes = openssl_random_pseudo_bytes( ceil( $padLength / 2 ) );
				}
				$uString = str_pad( $uString, $length, bin2hex( $rBytes ) );
			} else {
				$uString = substr( $uString, -$length );
			}
			return $uString;
		}
		
		/**
		 * Adds all files from the PHP superglobal $_FILES
		 */
		public function add_uploaded_files() {
			if ( $this->is_add_uploaded ) {
				throw new Exception( 'phpFileHandler->add_uploaded_files() already got called once.' );
			}
			$this->is_add_uploaded = true;
			foreach( $_FILES as $key => $data ) {
				$data['tmp_name'] = (array)$data['tmp_name'];
				$data['name'] = (array)$data['name'];
				$data['error'] = (array)$data['error'];
				for( $i = 0, $count = count( $data['tmp_name'] ); $i < $count; $i++ ) {
					$file = array(	'path'	=> $data['tmp_name'][$i],
										'origname' => $data['name'][$i],
										'name' => self::strip_to_valid_filename( $data['name'][$i] ),
										'isnew' => true	);
					
					// php.ini -> 'upload_max_filesize' exceeded error
					if ( $data['error'][$i] === UPLOAD_ERR_INI_SIZE ) {
						$this->add_invalid_file( $file, self::ERR_FILE_UPLOAD_SIZE ); 
						continue;
					}
					
					// guess the image extension by checking the type or name key value
					if ( !empty( $data['type'][$i] ) ) {
						$ext_guess = substr( strrchr( $data['type'][$i], '/' ), 1 );
					} else if ( strpos( $data['name'][$i], '.' ) !== false ) {
						$ext_guess = substr( strrchr( $data['name'][$i], '.' ), 1 );
					} else {
						$ext_guess = '';
					}
					$file['ext'] = str_replace( 'jpeg', 'jpg', $ext_guess );
				
					$this->process_file_add( $file );
				}
			}
		}
		
		/**
		 * Add a file from a web url
		 * @param string $url The file's web url
		 */
		public function add_file_from_url( $url ) {
			$url = ( substr( $url, 0, 4 ) !== 'http' ) ? 'http://' . str_replace( '//', '', $url ) : $url;
			$file = array(	'path'	=> $url,
								'origname' => $url,
								'name' => self::strip_to_valid_filename( substr( strrchr( $url, '/' ), 1 ) ),
								'isnew' => true,
								'ext' => ''	);
			$this->process_file_add( $file, true );
		}
		
		/**
		 * Adds files which are already existing on the Server for further processing
		 * @param string | array $filenames The file paths to add
		 */
		public function add_existing_files( $filenames ) {
			$filenames = (array)$filenames;
			for( $i = 0, $count = count( $filenames ); $i < $count; $i++ ) {
				$pathinfo = pathinfo( $filenames[$i] );
				$this->process_file_add( array(	'path'	=> $filenames[$i],
																'origname' => $pathinfo['basename'],
																'name' => $pathinfo['basename'],
																'savename' => $pathinfo['basename'] . '.' . $pathinfo['extension'],
																'isnew' => false,
																'ext' => $pathinfo['extension']	)	);
			}
		}
		
		/**
		 * Runs a file trough the main file checking process which is the only way to get valid files into @phpFileHandler->Files_valid
		 * @param array $file A phpFileHandler $file array
		 * @param boolean $isUrl True if $file['path'] is an web url
		 */
		protected function process_file_add( $file, $isUrl = false ) {
			// get the raw file content
			$bytestream = self::fileToByteStream( $file['path'], $isUrl );
			
			if ( $isUrl ) {
				if ( $bytestream === false || empty( $bytestream ) ) {
					return $this->add_invalid_file( $file, self::ERR_FILE_URL_READ ); 
				}
				// filter the mime type out from the response headers
				for( $i = 0, $count = count( $http_response_header ); $i < $count; $i++ ) {
					if ( strpos( strtolower( $http_response_header[$i] ), 'content-type' ) !== false ) {
						$file['ext'] = explode( '/', trim( explode( ';', explode( ':', $http_response_header[$i], 2 )[1], 2 )[0] ), 2 )[1];
					}
				}
			}
			
			// get the file size using mb_strlen or strlen (fallback when php_mbstring module is not loaded)
			// Note that this is only accurate when using mb_strlen because of mbstring.func_overload (which has been DEPRECATED as of PHP 7.2.0)
			$filesize = ( $this->is_mbstring_ext ) ? mb_strlen( $bytestream, '8bit' ) : strlen( $bytestream );
			if ( $this->MaxFileSize !== 0 && $filesize > $this->MaxFileSize ) {
				return $this->add_invalid_file( $file, self::ERR_FILE_UPLOAD_SIZE ); 
			}
			
			if ( $this->AllowedFileTypes ) {
				
				// check if the guessed extension is allowed
				if ( !in_array( $file['ext'], $this->AllowedFileTypes ) ) {
					return $this->add_invalid_file( $file['ext'], self::ERR_FILE_TYPE ); 
				}
				
				// if its a common media file make a hard filetype check
				if ( !self::check_mediafile( $bytestream, $file['ext'] ) ) {
					return $this->add_invalid_file( $file, self::ERR_FILE_TYPE ); 
				}
			}
			
			// filter the filename and remove the extension
			$dot_pos = strrpos( $file['name'], '.' );
			$file['name'] = ( $dot_pos !== false ) ? substr( $file['name'], 0, $dot_pos ) : $file['name'];
			
			if ( $isUrl ) {
				// generate a random temporary name for the file and save it to the system's default temp directory
				$file['path'] = tempnam( sys_get_temp_dir(), self::uniqString( 24 ) );
				file_put_contents( $file['path'], $bytestream );
			}
			
			if ( $this->is_gd2_ext ) {
				// check the orientation for the common image types
				if ( in_array( $file['ext'], self::FTY_IMAGES_GD ) ) {
					// see https://en.wikipedia.org/wiki/Exif for more information
					$exifReadData = exif_read_data( $file['path'] );
					if ( !empty( $exifReadData['Orientation'] ) ) {
						$newAngle = false;
						switch( $exifReadData['Orientation'] ) {
							case 3: { $newAngle = 180; } break;
							case 6: { $newAngle = -90; } break;
							case 8: { $newAngle = 90; } break;
						}
						if ( $newAngle ) {
							// quick roation adjust
							$image = imagecreatefromstring( $bytestream );
							$image = imagerotate( $image, $newAngle, 0 );
							self::save_image( $image, $file['path'], $file['ext'] );
						}
					}
				}
			}
			
			$file['size'] = $filesize;
			$this->add_valid_file( $file );
		}
		
		/**
		 * Saves all files in phpFileHandler->Files_valid to the given $savepath
		 * @param string $to The file save path
		 * @param boolean $allow_dir_create True to allow phpFileHandler to create the save path if not existing (recursive)
		 * @param integer $file_index Index of an phpFileHandler->Files_valid file
		 * @param string $name A custom filename when saving a single file
		 * @throws Exception
		 */
		public function save( $to, $allow_dir_create = false, $file_index = null, $name = null ) {
			$to = self::prepare_dir_string( $to );
			self::try_create_folder( $to, $allow_dir_create );
			if ( $file_index === null ) {
				for( $i = 0; $i < $this->Files_valid; $i++ ) {
					// generate a new filename or take the original
					$name = ( $this->is_uniq_filenames ) ? self::uniqString( $this->uniq_string_length ) : $this->Files_valid[$i]['name'];
					$savename = $name . '.' . $this->Files_valid[$i]['ext'];
					$new_path = $to . $savename;
					self::move_file( $this->Files_valid[$i]['path'], $new_path, $allow_dir_create );
					$this->Files_valid[$i]['name'] = $name;
					$this->Files_valid[$i]['savename'] = $savename;
					$this->Files_valid[$i]['path'] = $new_path;
					$this->Files_valid[$i]['issaved'] = true;
				}
			} else {
				if ( isset( $this->Files_valid[ $file_index ] ) ) {
					if ( !$this->Files_valid[ $file_index ]['issaved'] ) {
						throw new Exception( 'File on index "' . $file_index . '" already got saved.' );
					}
					// is a custom filename set?
					if ( !$name ) {
						// generate a new filename or take the original
						$name = ( $this->is_uniq_filenames ) ? self::uniqString( $this->uniq_string_length ) : $this->Files_valid[ $file_index ]['name'];
					}
					$savename = $name . '.' . $this->Files_valid[ $file_index ]['ext'];
					$new_path = $to . $savename;
					self::move_file( $file['path'], $new_path, $allow_dir_create );
					$this->Files_valid[ $file_index ]['name'] = $name;
					$this->Files_valid[ $file_index ]['savename'] = $savename;
					$this->Files_valid[ $file_index ]['path'] = $new_path;
					$this->Files_valid[ $file_index ]['issaved'] = true;
				} else {
					throw new Exception( 'Index "' . $file_index . '" does not exist in phpFileHandler->Files_valid.' );
				}
			}
		}
		
		/**
		 * Securely moves or copys a file to a new location
		 * @param string $filename The full path to file
		 * @param string $to Move to path
		 * @param boolean $allow_dir_create True to allow phpFileHandler to create the save path if not existing (recursive)
		 * @param boolean $allow_override True to allow file override
		 * @throws Exception
		 */
		public static function move_file( $filename, $to, $allow_dir_create = false, $copy = false, $allow_override = false ) {
			if ( !$allow_override && file_exists( $filename ) ) {
				throw new Exception( 'A file with the same name does already exist. (' . htmlspecialchars( $filename ) . ')' );
			}
			self::try_create_folder( $to, $allow_dir_create );
			if ( $copy ) {
				copy( $filename, $to );
			} else {
				if ( is_uploaded_file( $filename ) ) {
					// for in this session uploaded files only
					move_uploaded_file( $filename, $to );
				} else {
					// every other files
					rename( $filename, $to );
				}
			}
		}
		
		/**
		 * Trys to create a folder (recursive)
		 * @param string $dir The folder path
		 * @throws Exception
		 */
		protected static function try_create_folder( $dir, $allow_dir_create ) {
			if ( !is_dir( $dir ) ) {
				if ( $allow_dir_create ) {
					if ( !mkdir( $dir, 0777, true ) ) {
						throw new Exception( 'Unable to create folder, check the parent folder\'s permissions it must be writable for the system user which executes PHP.' );
					}
				} else {
					throw new Exception( '"' . htmlspecialchars( $dir ) . '" path does not exist, set @param $allow_dir_create to TRUE to allow path creation.' );
				}
			}
		}
		
		/**
		 * Checks the common media files ( @see phpFileHandler::FTY_MEDIA_COMMON )
		 * if the first bytes notation of the file match with the given filetype
		 * @param string $bytestream A raw file content as string
		 * @param string $ext An error severity constant
		 * @return boolean | integer if the file does not prove as common media file return will be positive integer
		 * Note that it is possible when $ext is empty, @return could be false when the first byte equals to one of the cases below
		 * or even in the very unlikely case true when all first bytes checked equals
		 */
		public static function check_mediafile( $bytestream, $ext = '' ) {
			$hexArr = self::bytestreamToHexCheckArray( $bytestream, $ext );
			if ( !empty( $ext ) ) {
				switch( $ext ) {
					case 'jpg': { return self::is_jpg( null, $hexArr ); } break;
					case 'gif': { return self::is_gif( null, $hexArr ); } break;
					case 'png': { return self::is_png( null, $hexArr ); } break;
					case 'mp4': { return self::is_mp4( null, $hexArr ); } break;
					case 'webm': { return self::is_webm( null, $hexArr ); } break;
					default: return 1;
				}
			} else {
				switch( $hexArr[0] ) {
					case 'FF': { return self::is_jpg( null, $hexArr ); } break;
					case '47': { return self::is_gif( null, $hexArr ); } break;
					case '89': { return self::is_png( null, $hexArr ); } break;
					default: {
						$hexArr = self::bytestreamToHexCheckArray( $bytestream, 'mp4' );
						switch( $hexArr[0] ) {
							case '66': { return self::is_mp4( null, $hexArr ); } break;
							case '1A': { return self::is_webm( null, $hexArr ); } break;
							default: return 1;
						}
					}
				}
			}
		}
		
		/**
		 * Gets the raw file byte data as string
		 * @param string $filename Path to the file
		 * @return string The raw byte stream from the given file as string
		 */
		protected static function fileToByteStream( $filename, $isUrl = false ) {
			if ( $isUrl ) {
				// $filename is a web url
				try {
					$bytestream = file_get_contents(
						$filename, false,
						stream_context_create(
							array(
								'http' => array(
									'method' => 'GET',
									'timeout' => 10	// timout after a 10 seconds connection attempt
								)
							)
						), 0, $this->MaxFileSize
					);
				} catch( Exception $exc ) {
					return false;
				}
			} else {
				if ( !file_exists( $filename ) ) {
					throw new Exception( 'The file: ' . htmlspecialchars( $filename ) . ' does not exist.' );
				}
				$bytestream = file_get_contents( $filename );
			}
			return $bytestream;
		}
		
		/**
		 * Converts raw bytestream file data to an array of 4 elements containing the hexadecimal representation of the first 4 bytes
		 * @param string $bytestream Raw file data
		 * @param string $ext An error severity constant
		 * @return array The first 4 hexadecimal values from the bytestream, for 'mp4' and 'webm' starting from the 5. byte position 
		 */
		protected static function bytestreamToHexCheckArray( $bytestream, $ext = null ) {
			$hexArr = array();
			for( ($i = ( $ext === 'mp4' || $ext === 'webm' ) ? 4 : 0); $i < 4; $i++ ) {
				$hexArr[] = strtoupper( bin2hex( $bytestream[$i] ) );
			}
			return $hexArr;
		}
		
		/**
		 * Checks if the given file or hexadecimal array agree with the first byte notation of the following media types:
		 * * jpg, gif, png, mp4, webm
		 * @param string $filename The path to the file
		 * @param array $hexArr An array containing hexadecimal representation of bytes from a file
		 */
		public static function is_jpg( $filename = null, $hexArr = null  ) {
			if ( $filename ) {
				$hexArr = self::bytestreamToHexCheckArray( self::fileToByteStream( $filename ), 'jpg' );
			}
			return ( $hexArr[0] === 'FF' && $hexArr[1] === 'D8' && $hexArr[2] === 'FF' ) ? true : false;
		}
		public static function is_gif( $filename = null, $hexArr = null  ) {
			if ( $filename ) {
				$hexArr = self::bytestreamToHexCheckArray( self::fileToByteStream( $filename ), 'gif' );
			}
			return ( $hexArr[0] === '47' && $hexArr[1] === '49' && $hexArr[2] === '46' ) ? true : false;
		}
		public static function is_png( $filename = null, $hexArr = null  ) {
			if ( $filename ) {
				$hexArr = self::bytestreamToHexCheckArray( self::fileToByteStream( $filename ), 'png' );
			}
			return ( $hexArr[0] === '89' && $hexArr[1] === '50' && $hexArr[2] === '4E' ) ? true : false;
		}
		public static function is_mp4( $filename = null, $hexArr = null  ) {
			if ( $filename ) {
				$hexArr = self::bytestreamToHexCheckArray( self::fileToByteStream( $filename ), 'mp4' );
			}
			return ( $hexArr[0] === '66' && $hexArr[1] === '74' && $hexArr[2] === '79' && $hexArr[3] === '70' ) ? true : false;
		}
		public static function is_webm( $filename = null, $hexArr = null  ) {
			if ( $filename ) {
				$hexArr = self::bytestreamToHexCheckArray( self::fileToByteStream( $filename ), 'webm' );
			}
			return ( $hexArr[0] === '1A' && $hexArr[1] === '45' && $hexArr[2] === 'DF' && $hexArr[3] === 'A3' ) ? true : false;
		}
		
		/**
		 * Strips all characters except from the folowing: 'a-z'  'A-Z'  '0-9'  '_'  '-'  '.'
		 * @param string $string
		 * @return string The stripped string
		 */
		private static function strip_to_valid_filename( $string ) {
			return preg_replace( '/[^\w-.]/', '', $string );
		}
		
		/**
		 * Returns a proper directory string with a leading '/'
		 * @param string $dir
		 * @return string The proper directory string
		 * * '\' -> '/'
		 * * '/Dir\Path\Here' -> '/Dir/Path/Here/'
		 */
		private static function prepare_dir_string( $dir ) {
			return rtrim( str_replace( '\\', '/', $dir ), '/' ) . '/';
		}

		/**
		 * Adds an invalid file with its error to $Files_invalid
		 * @param array $file
		 * @param integer $error An error severity constant
		 */
		protected function add_invalid_file( $file, $error ) {
			switch( $error ) {
				case 0: { $errorMsg = 'Exceeding the maximum upload file size. '; } break;
				case 1: { $errorMsg = 'Filetype not allowed.'; } break;
				case 2: { $errorMsg = 'Could not fetch the file from the web address.'; } break;
			}
			$file['error'] = $errorMsg;
			$file['isvalid'] = false;
			
			$this->Files_invalid[] = $file;
			$this->Files_invalid_count++;
			$this->add_file( $file );
			
			// delete the file if it is a new one
			if ( $file['isnew'] ) {
				unlink( $file['path'] );
			}
		}
		
		/**
		 * Adds an valid file to $Files_valid
		 * @param array $file
		 */
		protected function add_valid_file( $file ) {
			$file['error'] = '';
			$file['isvalid'] = true;
			$file['name'] = ( empty( $file['name'] ) ) ? self::uniqString() : $file['name'];
			$file['issaved'] = false;
			$file['savename'] = $file['savename'] ?? null;
			
			$this->Files_valid[] = $file;
			$this->Files_valid_count++;
			$this->add_file( $file );
		}
		
		/**
		 * Adds an added file regardless of whether valid or invalid to $Files
		 * @param array $file
		 */
		protected function add_file( $file ) {
			$this->Files[] = $file;
			$this->Files_count++;
		}
		
	/******
	 *			-------------------------------------------------------------
	 *			|															|
	 *			|		IMAGE HANDLING SECTION 		|
	 *			|															|
	 *			-------------------------------------------------------------
	 *
	 * phpImageHandler - All in one php image handling using the GD extension !
	 * make sure the gd2 extension is loaded
	 * NOTE: For very big images the script memory usage may need to be elevated
	 * On my machine (WIN7, XAMPP, PHP7) a 12MB image took ~32MB on peak
	 * PHP's default 'memory_limit' is set to '128M'...
	 * Nonetheless you will notice when getting the Fatal error: 'Out of memory' occurs
	 *
	 **/

		/* Create a thumbnail in the same folder as the reference image
		 * if $filename is null, it will create a thumb from every image file from @phpFileHandler->Files_valid
		 * @param string $size See @param $type for explanation
		 * @param string $to Set a save path for the thumb
		 * @param string $filename Path to the image file
		 * @param string $type An image resource possible type:
		 * * If the image is smaller than $size it will just create a copy with the prefixed name
		 * * '': $size will define the maximum height or width depending on the largest side, image will scale down proportional
		 * * 'iso': The image will be cropped centered to a Isosceles square each side with the lenght of $size
		 * @param string $prefix Adds a prefix after the filename ( 'image.jpg' -> 'image_thumb.jpg' )
		 * * Note when you set an empty prefix if a file with the same name exists in the given directory it will be overwritten !
		 */
		public function thumb( $size, $to = null, $filename = null, $type = '', $prefix = '_thumb' ) {
			if ( $to ) {
				if ( !is_dir( $to ) ) {
					throw new Exception( htmlspecialchars( $to ) . ' is not a directory or does not exist.' );
				}
				$to = self::prepare_dir_string( $to );
			}
			if ( !$filename ) {
				// generate a thumb for each of the phpFileHandler->Files_valid
				for( $i = 0; $i < $this->Files_valid; $i++ ) {
					if ( in_array( $this->Files_valid[$i]['ext'], self::FTY_IMAGES_GD ) ) {
						$savepath = ( !$to ) ? $this->Files_valid[$i]['path'] : $to . $this->Files_valid[$i]['savename'];
						$image = self::create_image( $this->Files_valid[$i]['path'], $this->Files_valid[$i]['ext'], $size, $type );
						self::save_image( $image, $savepath, $this->Files_valid[$i]['ext'], $prefix );
					}
				}
			} else {
				if ( !file_exists( $filename ) ) {
					throw new Exception( 'File does not exist (' . htmlspecialchars( $filename ) . ')' );
				}
				// generate a thumb for the given file if its an image file which can be handled by GD
				$ext = substr( strrchr( $filename, '.' ), 1 );
				if ( in_array( $ext, self::FTY_IMAGES_GD ) ) {
					$savepath = ( !$to ) ? $filename : $to . substr( $filename, strrpos( $filename, '/' )+1 );
					$image = self::create_image( $filename, $ext, $size, $type );
					self::save_image( $image, $savepath, $ext, $prefix );
				}
			}
		}
		
		/**
		 * Generates the settings for the thumb used in imagecopyresampled() function
		 * @param integer $width Orignial image width
		 * @param integer $height Orignial image height
		 * @param integer $size The destination size
		 * @param string $type An image resource possible type
		 * @return array | boolean
		 * * false: if the destination size is bigger than the original
		 * * array with the calculated destination 'width', 'height', 'x', 'y'
		 */
		private static function generate_thumbsettings( $width, $height, $size, $type = '' ) {
			switch( $type ) {
				case 'iso': {
					if ( $width < $height ) {
						if ( $size > $height ) {
							return false;
						}
						$y = ( $height / 2 ) - ( $width / 2 );
						$height = $width;
					} else {
						if ( $size > $width ) {
							return false;
						}
						$x = ( $width / 2 ) - ( $height / 2 );
						$width = $height;
					}
					$dst_width = $dst_height = $size;
				} break;
				default: {
					if ( $width > $height ) {
						if ( $size > $width ) {
							return false;
						}
						$dst_width = $size;
						$dst_height = round( $size / ($width / $height) );
					} else {
						if ( $size > $height ) {
							return false;
						}
						$dst_height = $size;
						$dst_width = round( $size / ($height / $width) );
					}
				}
			}
			return array(	'dst_width' => $dst_width,
								'dst_height' => $dst_height,
								'x' => $x ?? 0,
								'y' => $y ?? 0	);
		}
		
		/**
		 * Generates the settings for the thumb used in imagecopyresampled() function
		 * @param integer $width Orignial image width
		 * @param integer $height Orignial image height
		 * @param integer $size The destination size
		 * @param string $type An image resource possible type
		 * @return array | boolean
		 * * false: if the destination size is bigger than the original
		 * * array with the calculated destination 'width', 'height', 'x', 'y'
		 */
		private function create_image( $filename, $ext, $size, $type ) {
			// create an image resource from the original image
			switch( $ext ) {
				case 'jpeg':
				case 'jpg': { $image = imagecreatefromjpeg( $filename ); } break;
				case 'gif': { $image = imagecreatefromgif( $filename ); } break;
				case 'png': { $image = imagecreatefrompng( $filename ); } break;
				case 'gd': { $image = imagecreatefromgd( $filename ); } break;
				case 'gd2': { $image = imagecreatefromgd2( $filename ); } break;
				case 'bmp': { $image = imagecreatefrombmp( $filename ); } break;
				case 'wbmp': { $image = imagecreatefromwbmp( $filename ); } break;
				case 'webp': { $image = imagecreatefromwebp( $filename ); } break;
				case 'xbm': { $image = imagecreatefromxbm( $filename ); } break;
				default: throw new Exception( 'GD extension cannot create an image from this image type ("' . htmlspecialchars( $ext ) . '")' ); 
			}
			
			$image_width = imagesx( $image );
			$image_height = imagesy( $image );
			
			// get the settings for the thumb image creation
			$settings = self::generate_thumbsettings( $image_width, $image_height, $size, $type );

			// settings return false if the destination $size is bigger than the original image
			if ( $settings ) {
				// create a new empty image
				$thumb_image = imagecreatetruecolor( $settings['dst_width'], $settings['dst_height'] );
				if ( $ext !== 'jpeg' && $ext !== 'jpg' ) {
					// create an alpha canal for the image and set the background to fully transparent
					imagecolortransparent( $thumb_image, imagecolorallocatealpha( $thumb_image, 0, 0, 0, 127 ) );
					imagealphablending( $thumb_image, false );
					imagesavealpha( $thumb_image, true );
				}
				imagecopyresampled(
					$thumb_image, $image,									//	dst_image,	src_image,
					0, 0,																//	dst_x,			dst_y,
					$settings['x'], $settings['y'],								//	src_x,			src_y,
					$settings['dst_width'], $settings['dst_height'],	//	dst_w,			dst_h,
					$image_width, $image_height							//	src_w,			src_h
				);

				return $thumb_image;
			} else {
				return $image;
			}
		}
		
		/**
		 * Saves an image resource to a file 
		 * NOTE that this function will overwrite an existing file with the same name
		 * @param resource $image An image resource
		 * @param string $filename The path to save the image
		 * @param string $ext The filetype extension
		 * @param string $prefix Adds a prefix after the filename ( 'image.jpg' -> 'image_thumb.jpg' )
		 */
		public static function save_image( $image, $filename, $ext, $prefix = '' ) {
			if ( !empty( $prefix ) ) {
				$filename = substr( $filename, 0, strrpos( $filename, '.' )  ) . $prefix . strrchr( $filename, '.' );
			}
			switch( $ext ) {
				case 'jpeg':
				case 'jpg': { imagejpeg( $image, $filename ); } break;
				case 'gif': { imagegif( $image, $filename ); } break;
				case 'png': { imagepng( $image, $filename ); } break;
				case 'gd': { imagegd( $image, $filename ); } break;
				case 'gd2': { imagegd2( $image, $filename ); } break;
				case 'bmp': { imagebmp( $image, $filename ); } break;
				case 'wbmp': { imagewbmp( $image, $filename ); } break;
				case 'webp': { imagewebp( $image, $filename ); } break;
				case 'xbm': { imagexbm( $image, $filename ); } break;
				default: throw new Exception( 'GD extension cannot create an image from this image type ("' . htmlspecialchars( $ext ) . '")' ); 
			}
		}
		
	}
	
